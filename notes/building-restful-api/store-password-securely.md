{%hackmd BJrTq20hE %}
# How to securely store passwords?
###### tags: `simplebank`

Section 7 of [Building RESTful HTTP JSON API](/Ts3fNR-oTPCvC2mnrWDHyQ)

[article](https://dev.to/techschoolguru/how-to-securely-store-passwords-3cg7)
[youtube](https://www.youtube.com/watch?v=mJ8b5GcvoxQ&list=PLy_6D98if3ULEtXtNSY_2qN21VCKgoQAE&index=17)

In this lecture, we’re gonna learn ***how to securely store users’ password in the database***.

# How to store password
The idea is to hash it first, and only store that hash value.
- hash the password with `bcrypt`
    - `cost` parameter
        - decides the number of key expansion rounds or iterations of the algorithm
    - `salt`, generated by Bcrypt
        - helps protect against the `rainbow table attack`
        - give you a completely different output hash value even if the same input password is provided.

![](https://i.imgur.com/8DdoAYn.png)
* The first part is the `hash algorithm identifier`.
    * 2A is the identifier of the bcrypt algorithm.
* The second part is the `cost`. 
    * In this case, the cost is 10, which means there will be 2^10 = 1024 rounds of key expansion.
* The third part is the `salt` of length 16 bytes, or 128 bits. 
    * It is encoded using `base64` format, which will generate a string of 22 characters.
* Finally, the last part is the 24 bytes `hash value`, encoded as 31 characters.

All of these 4 parts are concatenated together into a single hash string, and it is the string that we will store in the database.
![](https://i.imgur.com/YE45SLU.png)

## How to verify the password entered by user?
1. find the `hashed_password` stored in the DB by `username`.
2. hash the `naked_password` users just entered with `bcrypt`
3. compare the 2 hash values

![](https://i.imgur.com/hkbA0Um.png)

# Implement functions to hash and compare passwords
We’re gonna update our code to use a real hash string.

## Hash password function
```go
func HashPassword(password string) (string, error) {
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return "", fmt.Errorf("failed to hash password: %w", err)
    }
    return string(hashedPassword), nil
}
```

This function will compute the bcrypt hash string of the input password.

## Compare passwords function

write another function to check if a password is correct or not: `CheckPassword()`.

`bcrypt` package has already implemented this feature

```
// CheckPassword checks if the provided password is correct or not
func CheckPassword(password string, hashedPassword string) error {
    return bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
}
```

## Write unit test for HashPassword and CheckPassword functions

1. check that hashedPassword should pass CheckPassword with NakedPassword
```go
func TestPassword(t *testing.T) {
    password := RandomString(6)

    hashedPassword, err := HashPassword(password)
    require.NoError(t, err)
    require.NotEmpty(t, hashedPassword)

    err = CheckPassword(password, hashedPassword1)
    require.NoError(t, err)
}
```

2. test the case where an incorrect password is provided

```go
wrongPassword := RandomString(6)
    err = CheckPassword(wrongPassword, hashedPassword)
    require.EqualError(t, err, bcrypt.ErrMismatchedHashAndPassword.Error())
```

`output error` should equal to `bcrypt.ErrMismatchedHashAndPassword`

## Update the existing code to use HashPassword function

1. update `createRandomUser()` in `user_test.go`

```go
func createRandomUser(t *testing.T) User {
    hashedPassword, err := util.HashPassword(util.RandomString(6))
    require.NoError(t, err)

    arg := CreateUserParams{
        Username:       util.RandomOwner(),
        HashedPassword: hashedPassword,
        FullName:       util.RandomOwner(),
        Email:          util.RandomEmail(),
    }

    ...
}
```

2. let’s run the whole db package test!
3. All passed
    - check users table
        ![](https://i.imgur.com/FgdKhVW.png)

# Make sure all hashed passwords are different

One thing we want to make sure of is:

>if the same password is hashed twice, 2 different hash values should be produced.

```go
hashedPassword2, err := HashPassword(password)
require.NoError(t, err)
require.NotEmpty(t, hashedPassword2)
require.NotEqual(t, hashedPassword1, hashedPassword2)
```