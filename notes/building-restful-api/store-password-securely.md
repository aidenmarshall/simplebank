{%hackmd BJrTq20hE %}
# How to securely store passwords?
###### tags: `simplebank`

Section 7 of [Building RESTful HTTP JSON API](/Ts3fNR-oTPCvC2mnrWDHyQ)

[article](https://dev.to/techschoolguru/how-to-securely-store-passwords-3cg7)
[youtube](https://www.youtube.com/watch?v=mJ8b5GcvoxQ&list=PLy_6D98if3ULEtXtNSY_2qN21VCKgoQAE&index=17)

In this lecture, we’re gonna learn ***how to securely store users’ password in the database***.

# How to store password
The idea is to hash it first, and only store that hash value.
- hash the password with `bcrypt`
    - `cost` parameter
        - decides the number of key expansion rounds or iterations of the algorithm
    - `salt`, generated by Bcrypt
        - helps protect against the `rainbow table attack`
        - give you a completely different output hash value even if the same input password is provided.

![](https://i.imgur.com/8DdoAYn.png)
* The first part is the `hash algorithm identifier`.
    * 2A is the identifier of the bcrypt algorithm.
* The second part is the `cost`. 
    * In this case, the cost is 10, which means there will be 2^10 = 1024 rounds of key expansion.
* The third part is the `salt` of length 16 bytes, or 128 bits. 
    * It is encoded using `base64` format, which will generate a string of 22 characters.
* Finally, the last part is the 24 bytes `hash value`, encoded as 31 characters.

All of these 4 parts are concatenated together into a single hash string, and it is the string that we will store in the database.
![](https://i.imgur.com/YE45SLU.png)

## How to verify the password entered by user?
1. find the `hashed_password` stored in the DB by `username`.
2. hash the `naked_password` users just entered with `bcrypt`
3. compare the 2 hash values

![](https://i.imgur.com/hkbA0Um.png)

# Implement functions to hash and compare passwords
We’re gonna update our code to use a real hash string.

## Hash password function
```go
func HashPassword(password string) (string, error) {
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return "", fmt.Errorf("failed to hash password: %w", err)
    }
    return string(hashedPassword), nil
}
```

This function will compute the bcrypt hash string of the input password.

## Compare passwords function

write another function to check if a password is correct or not: `CheckPassword()`.

`bcrypt` package has already implemented this feature

```
// CheckPassword checks if the provided password is correct or not
func CheckPassword(password string, hashedPassword string) error {
    return bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
}
```

## Write unit test for HashPassword and CheckPassword functions

1. check that hashedPassword should pass CheckPassword with NakedPassword
```go
func TestPassword(t *testing.T) {
    password := RandomString(6)

    hashedPassword, err := HashPassword(password)
    require.NoError(t, err)
    require.NotEmpty(t, hashedPassword)

    err = CheckPassword(password, hashedPassword1)
    require.NoError(t, err)
}
```

2. test the case where an incorrect password is provided

```go
wrongPassword := RandomString(6)
    err = CheckPassword(wrongPassword, hashedPassword)
    require.EqualError(t, err, bcrypt.ErrMismatchedHashAndPassword.Error())
```

`output error` should equal to `bcrypt.ErrMismatchedHashAndPassword`

## Update the existing code to use HashPassword function

1. update `createRandomUser()` in `user_test.go`

```go
func createRandomUser(t *testing.T) User {
    hashedPassword, err := util.HashPassword(util.RandomString(6))
    require.NoError(t, err)

    arg := CreateUserParams{
        Username:       util.RandomOwner(),
        HashedPassword: hashedPassword,
        FullName:       util.RandomOwner(),
        Email:          util.RandomEmail(),
    }

    ...
}
```

2. let’s run the whole db package test!
3. All passed
    - check users table
        ![](https://i.imgur.com/FgdKhVW.png)

# Make sure all hashed passwords are different

One thing we want to make sure of is:

>if the same password is hashed twice, 2 different hash values should be produced.

```go
hashedPassword2, err := HashPassword(password)
require.NoError(t, err)
require.NotEmpty(t, hashedPassword2)
require.NotEqual(t, hashedPassword1, hashedPassword2)
```

# Implement the create user API
use the HashPassword() function that we’ve written to implement the create user API

## createUserRequest struct
```go
type createUserRequest struct {
    Username string `json:"username" binding:"required,alphanum"`
    Password string `json:"password" binding:"required,min=6"`
    FullName string `json:"full_name" binding:"required"`
    Email    string `json:"email" binding:"required,email"`
}
```

Use useful tags implemented by the validator package
- `alphanum` tag
    -  It basically means that this field should contain ASCII alphanumeric characters only.

- `min` tag
    - to say the length of the password should be at least 6 characters.

- `email` tag
    - use the email tag provided by validator package to make sure that the value of this field is a correct email address.

## complete the `createUser()` function
```go
func (server *Server) createUser(ctx *gin.Context) {
    var req createUserRequest
    if err := ctx.ShouldBindJSON(&req); err != nil {
        ctx.JSON(http.StatusBadRequest, errorResponse(err))
        return
    }

    hashedPassword, err := util.HashPassword(req.Password)
    if err != nil {
        ctx.JSON(http.StatusInternalServerError, errorResponse(err))
        return
    }

    arg := db.CreateUserParams{
        Username:       req.Username,
        HashedPassword: hashedPassword,
        FullName:       req.FullName,
        Email:          req.Email,
    }

    ...   
}
```

we compute the hashedPassword by calling util.HashPassword() function and pass in the input request.Password value.

### call server.store.CreateUser()
```go
func (server *Server) createUser(ctx *gin.Context) {
    ...

    user, err := server.store.CreateUser(ctx, arg)
    if err != nil {
        if pqErr, ok := err.(*pq.Error); ok {
            switch pqErr.Code.Name() {
            case "unique_violation":
                ctx.JSON(http.StatusForbidden, errorResponse(err))
                return
            }
        }
        ctx.JSON(http.StatusInternalServerError, errorResponse(err))
        return
    }

    ctx.JSON(http.StatusOK, user)
}
```

In the users table, since we have 2 unique constraints:

- One is for the primary key username,
- And the other is for the email column.

, we need to handle `unique_violation` error.

Return status `403` in case an user with the same username or email already exists.

### resiter a route for `createUser` API handler

# API should not expose hashed password
The hashed_password value is also returned.

It would be better to remove this field from the response body.

## declare a new createUserResponse struct

It will contain almost all fields of the db.User struct, except for the HashedPassword field that should be removed.
```go
type createUserResponse struct {
    Username          string    `json:"username"`
    FullName          string    `json:"full_name"`
    Email             string    `json:"email"`
    PasswordChangedAt time.Time `json:"password_changed_at"`
    CreatedAt         time.Time `json:"created_at"`
}
```

Finally, we return the response object instead of user. And we’re done.

```go
func (server *Server) createUser(ctx *gin.Context) {
    ...

    user, err := server.store.CreateUser(ctx, arg)
    if err != nil {
        if pqErr, ok := err.(*pq.Error); ok {
            switch pqErr.Code.Name() {
            case "unique_violation":
                ctx.JSON(http.StatusForbidden, errorResponse(err))
                return
            }
        }
        ctx.JSON(http.StatusInternalServerError, errorResponse(err))
        return
    }

    rsp := createUserResponse{
        Username:          user.Username,
        FullName:          user.FullName,
        Email:             user.Email,
        PasswordChangedAt: user.PasswordChangedAt,
        CreatedAt:         user.CreatedAt,
    }
    ctx.JSON(http.StatusOK, rsp)
}
```